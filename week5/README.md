# WEEK5 그리디

### 1. 11047 동전0

- 주어진 화폐금액의 최대값 부터 값을 나누어주면서 결과변수에 더해줌



### 2. 2217 로프

- 버틸수 있는 무게가 가장 작은 로프 x 남은 로프의 수 값을 비교하여 최종 max값 출력

- ```c+
  //가장 작은 로프부터 시작하기 위해 sorting 해준다.
  	sort(a,a+n);
  	int max=0;
  	for(int i=0;i<n;i++){
  		if(max<a[i]*(n-i)) max=a[i]*(n-i);
  	} 
  	cout<<max;
  ```



### 3. 1931 회의실배정

- 회의가 끝나는 시간을 오름차순으로 정렬해 준뒤, 시작시간이 끝난 시간보다 크거나 같다면 끝나는 시간을 갱신해주면서 counting 해준다.

- ```c+
  for(int i=0;i<n;i++){
  		if(v[i].first>=start){
  			start=v[i].second;
  			ans++;
  		}
  	}
  ```

### 4 . 2529 부등호 ★

- 순열을 이용하는 그리디 알고리즘 문제였다. 순열을 통해 접근해야 하는 부분에서 막혔던 문제.

- 그리디하게 접근했을 때 최대 숫자는 9 ~ (9 - K)의 숫자들로 이루어질 것이고 최소 숫자는 0 ~ K까지의 숫자들로 이루어질 것이다.

  - i) 최대 숫자에 대해 모순이 발생하면 prev_permutation 함수를 이용하여 해당 숫자보다 작으면서 최대인 숫자로 바꿔준다.
  - ii) 최소 숫자에 대해 모순이 발생하면 next_permutation 함수를 이용하여 해당 숫자보다 크면서 최소인 숫자로 바꿔준다

- 최대 숫자와 최소 숫자를 출력해준다.

- 참고 출처 : <https://jaimemin.tistory.com/758>

  

### 느낀점

- 그리디 알고리즘은 현재상황에서 가장 이득을 볼 수 있는 값을 찾아가면서 완성되는 알고리즘이기 때문에 처음에 정렬해야하는 경우가 대부분이었다.
- 백트래킹 문제와는 다르게 접근법만 잘 찾는다면 코딩 분량자체는 많지 않다.
- 유형에 따라 백트래킹 기법도 써야 하는 문제가 있다.